---
title: 内核的几个题
tags:
  - 题目
categories: '内核'
comments: true
copyright: true
date: 2018-10-23 16:33:36
---
## 下半部的三种实现机制区别：

|下半部的三种实现机制	|所处上下文	|区别|
|------------|-------|-----------|
|软中断	|中断上下文	|不可抢占和阻塞，不可睡眠，同类型可以在不同cpu上同时执行|
|tasklet|	中断上下文	|不可抢占和阻塞，不可睡眠，同类型不能同时执行在不同cpu上|
|工作队列	|进程上下文	|可能被调度、抢占、阻塞，可睡眠|

## 工作队列与哪些接口：

		struct workqueue_struct *create_workqueue(const char *name); //工作队列的创建，也可不创建，内核缺省队列；

		DECLARE_WORK(name, void (*function)(void *), void *data); //在编译期初始化一个工作任务；

		INIT_WORK(struct work_struct *work, void (*function)(void *), void *data); //在运行期初始化一个工作任务；

		int queue_work(struct workqueue_struct *queue, struct work_struct *work);  //把一个任务加到工作队列中；
		int queue_delayed_work(struct workqueue_struct *queue, struct work_struct *work, unsigned long delay); //至少在经过一段给定的最小延迟时间以后，工作队列中的任务才可以真正执行。

		int cancel_delayed_work(struct work_struct *work); //取消一个任务；

		void flush_workqueue(struct workqueue_struct *queue); //清空工作队列；

		void destroy_workqueue(struct workqueue_struct *queue); //销毁工作队列；

		int schedule_work(struct work_struct *work); //向内核缺省的工作队列中添加一个任务；
		int schedule_delayed_work(struct work_struct *work, unsigned long delay); // 向内核缺省工作队列中添加一个任务并延迟执行。

所以内核中使用内核缺省的工作队列时只需三步：

		INIT_WORK(struct work_struct *work, void (*function)(void *), void *data); ——在运行期初始化一个工作任务
        int schedule_work(struct work_struct *work); -- 向内核缺省的工作队列中添加一个任务；
        定义INIT_WORK中为work绑定的处理函数（void (*function)(void *)），即work的handler。
        
## 锁都有哪些,区别？中断下半段的锁？

互斥锁、读写锁、自旋锁、信号量、顺序锁；

## 区别：

互斥锁：阻塞等待，cpu可以去进行其他任务；

自旋锁：忙等待，会一直在 cpu上进行忙等待并不停的进行锁请求，直到得到这个锁为止。

信号量：阻塞等待；

读写锁：1）多个读者可以同时进行读 2）写者必须互斥 3）写者优先于读者——自旋锁的衍生锁

顺序锁：基于访问计数器的锁。——自旋锁的衍生锁


## 中断下半段的锁：

中断下半段有三种机制：软中断、tasklet、工作队列。根据三种机制，可用的锁不一样。软中断和tasklet不可阻塞，所以上述锁中阻塞等待的锁都不可用，只能用自旋锁；而工作队列运行在进程上下文中，所以占尽进程上下文的所有优势，允许被重新调度和睡眠，可随意使用锁。