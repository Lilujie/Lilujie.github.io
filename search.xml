<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内核的几个题]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%86%85%E6%A0%B8%E7%9A%84%E5%87%A0%E4%B8%AA%E9%A2%98%2F</url>
    <content type="text"><![CDATA[下半部的三种实现机制区别： 下半部的三种实现机制 所处上下文 区别 软中断 中断上下文 不可抢占和阻塞，不可睡眠，同类型可以在不同cpu上同时执行 tasklet 中断上下文 不可抢占和阻塞，不可睡眠，同类型不能同时执行在不同cpu上 工作队列 进程上下文 可能被调度、抢占、阻塞，可睡眠 工作队列与哪些接口： struct workqueue_struct *create_workqueue(const char *name); //工作队列的创建，也可不创建，内核缺省队列； DECLARE_WORK(name, void (*function)(void *), void *data); //在编译期初始化一个工作任务； INIT_WORK(struct work_struct *work, void (*function)(void *), void *data); //在运行期初始化一个工作任务； int queue_work(struct workqueue_struct *queue, struct work_struct *work); //把一个任务加到工作队列中； int queue_delayed_work(struct workqueue_struct *queue, struct work_struct *work, unsigned long delay); //至少在经过一段给定的最小延迟时间以后，工作队列中的任务才可以真正执行。 int cancel_delayed_work(struct work_struct *work); //取消一个任务； void flush_workqueue(struct workqueue_struct *queue); //清空工作队列； void destroy_workqueue(struct workqueue_struct *queue); //销毁工作队列； int schedule_work(struct work_struct *work); //向内核缺省的工作队列中添加一个任务； int schedule_delayed_work(struct work_struct *work, unsigned long delay); // 向内核缺省工作队列中添加一个任务并延迟执行。 所以内核中使用内核缺省的工作队列时只需三步： INIT_WORK(struct work_struct *work, void (*function)(void *), void *data); ——在运行期初始化一个工作任务 int schedule_work(struct work_struct *work); -- 向内核缺省的工作队列中添加一个任务； 定义INIT_WORK中为work绑定的处理函数（void (*function)(void *)），即work的handler。 锁都有哪些,区别？中断下半段的锁？互斥锁、读写锁、自旋锁、信号量、顺序锁； 区别：互斥锁：阻塞等待，cpu可以去进行其他任务； 自旋锁：忙等待，会一直在 cpu上进行忙等待并不停的进行锁请求，直到得到这个锁为止。 信号量：阻塞等待； 读写锁：1）多个读者可以同时进行读 2）写者必须互斥 3）写者优先于读者——自旋锁的衍生锁 顺序锁：基于访问计数器的锁。——自旋锁的衍生锁 中断下半段的锁：中断下半段有三种机制：软中断、tasklet、工作队列。根据三种机制，可用的锁不一样。软中断和tasklet不可阻塞，所以上述锁中阻塞等待的锁都不可用，只能用自旋锁；而工作队列运行在进程上下文中，所以占尽进程上下文的所有优势，允许被重新调度和睡眠，可随意使用锁。]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[request_threaded_irq]]></title>
    <url>%2F2018%2F10%2F23%2Frequest-threaded-irq%2F</url>
    <content type="text"><![CDATA[函数原型： int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char devname, void dev_id) 输入参数 描述 irq 中断号 handler 中断处理函数 thread_fn 要在内核线程中调用的函数 irqflags 在驱动中是中断触发类型 输出参数：0表示成功执行，负数表示各种错误原因。 中断号：在驱动中，一般会由中断的gpio号得到，如 irq_num = gpio_to_irq(bdata-&gt;irq_gpio); handler:中断处理函数，在驱动中一般这个参数是NULL，为NULL时使用默认的处理，这个相当于中断的上半段。 thread_fn：中断发生时，如果handler为NULL，就直接将thread_fn扔到内核线程中去执行。 irqflags：类似于IRQF_ONESHOT | IRQF_TRIGGER_LOW表示中断触发方式为低电平触发。 &emsp;&emsp;这个函数将中断线程化，中断将作为内核线程运行，可被赋予不同的实时优先级。在负载较高时，中断线程可以被挂起，以避免某些更高优先级的实时任务得不到及时响应。]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内核支持抢占和非抢占的含义]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81%E6%8A%A2%E5%8D%A0%E5%92%8C%E9%9D%9E%E6%8A%A2%E5%8D%A0%E7%9A%84%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[Linux2.4不支持内核抢占，即是说进程通过系统调用陷入到内核态的时候，不可以被其他的进程抢占。如果有更高优先级的进程，只有在系统调用返回用户空间的时候，才可被调度程序调度，由高优先级的进程占用cpu。这里的“不可以被其他进程抢占”当然不包括中断上下文，无论内核态还是用户态，中断上下文都可以抢占进程上下文，中断上下文是拥有最高的权限，它甚至可以抢占其他的中断上下文。 Linux2.6有一个CONFIG_PREEMPT的选项，打开该选项后，linux kernel就支持了内核代码的抢占。对于抢占式内核而言，即便是从中断上下文返回内核空间的进程上下文，只要内核代码不在临界区内，就可以发生调度，让最高优先级的任务调度执行。例如高优先级的进程可以抢占内核态的系统调用，而不必等系统调用执行完返回用户空间才抢占。]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>内核抢占</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伙伴系统与slab/slub分配器]]></title>
    <url>%2F2018%2F10%2F23%2F%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E4%B8%8Eslab-slub%E5%88%86%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;内存管理有两个算法：伙伴算法和slab/slub算法。伙伴算法是以页为单位管理内存，slab算法是以字节为单位管理内存，是内核的小内存管理算法。slab分配器并没有脱离伙伴系统，而是基于伙伴系统分配的大内存进一步细分成小内存。先讲伙伴系统，再讲slab分配器。 &emsp;&emsp;伙伴系统是基于bootmem机制来分配一些数据结构的。bootmem初始化的时候会调用free_area_init_node来对内存域zone数据结构进行初始化。zone包含一个frea_area的结构体来描述本ZONE的空闲页块链表，也会在bootmem初始化zone时被一并初始化。 struct zone { ... /* free areas of different sizes */ struct free_area free_area[MAX_ORDER]; ... } ____cacheline_internodealigned_in_smp; &emsp;&emsp;注意struct free_area free_area[MAX_ORDER]是一个以链表为元素的数组，数组的每个元素都是某个阶数的空闲内存块的链表。 &emsp;&emsp;MAX_ORDER（最大阶数）一般默认为11，代表有11个free_area，即有11组空闲页块的链表。 例如free_area[0]：是一个链表，该链表里是长度为1的页块。即这个链表里有若干内存块，每个内存块都是1个page。 free_area[10]：也是一个链表，该链表里是长度为1024的页块。即这个链表里有若干内存块，每个内存块都是1024个page（4M内存空间）。 free_area的下标与该元素的链表中的内存块大小存在2的阶的关系。 &emsp;&emsp;那么什么是伙伴呢？如果同一个链表中的两个页块满足下面这三个条件，我们就称这两个页块为伙伴： &emsp;&emsp;1) 两个块的大小相同，假设为b。 &emsp;&emsp;2) 两个块的物理地址连续。 &emsp;&emsp;3) 伙伴中第一个块的起始物理地址是2bPAGE_SIZE的整数倍。即第0块和第1块是伙伴，第2块和第3块是伙伴，但是第1块和第2块不是伙伴。这样规定的目的是确保一对伙伴中的两个块可以合并成更高一级的大块。 &emsp;&emsp;伙伴的关系有三种，（1）一个被分配时，那么另一个就等着这个分配出去的块被释放后合并，然后递归的进行更大order的合并；（2）如果两个都被分配，那么肯定有一个先被释放，那么化为情况一，注意在等待伙伴被释放的同时，该块可以被分配，从而情况一化为情况二，但是最终它们结果总是趋向于情况三，也就是都被释放从而被合并然后插入到更大一层的链表中。——有效防止内存碎片的产生。 &emsp;&emsp;如果链表的阶数为n，页块1的页号为page_id，其伙伴的页号查找公式为： buddy_id = page_id ^ (1 &lt;&lt; n) &emsp;&emsp;伙伴系统申请内核内存的接口有：alloc_pages，_ _get_free_pages等。 &emsp;&emsp;slub分配的原理可参考如下文章：https://blog.csdn.net/lukuen/article/details/6935068 &emsp;&emsp;我们在驱动开发的时候经常用到kmalloc函数，它就是基于slab分配器实现的。例如，我们分配一个17Bytes的内存，会这样调用：kmalloc(17, GFP_KERNEL)，系统会从名称“kmalloc-32”管理的slab缓存池中分配一个对象，即使浪费了剩余的15Byte。]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上下文理解]]></title>
    <url>%2F2018%2F10%2F22%2F%E4%B8%8A%E4%B8%8B%E6%96%87%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[举例： 定时器到了，执行定时器的handler function，这算处于中断上下文。 内核调度，调度的线程、进程，这算处于进程上下文。。。 中断线程化： 内核中有一个中断线程化的概念，属于中断下半部的范畴，中断线程是可以被调度的，处于进程上下文。 workqueue 在中断线程化机制合入Linux内核之前，中断下半部的三种旧实现机制（SoftIRQ、tasklet、workqueue）中的workqueue，就有了一些中断线程化的影子。workqueue的基本原理就是把需要推迟执行的工作，交由一个内核线程来执行，它是利用进程上下文来执行中断下半部的操作，因此workqueue允许重新调度和睡眠。 中断上下文和中断上半部下半部 在这里容易混淆中断上下文和中断上半部下半部的概念。中断上下文指的是中断发生时，CPU响应一个中断并执行中断服务程序时，内核处于中断上下文。中断服务程序处于中断上半部，然后一些耗时的操作会放在下半部执行。换句话说，一个完整的中断处理流程包含中断处理程序和中断下半部。我们经常说中断上下文中不能调用含有睡眠的函数，其实与中断上半段不能执行一些耗时操作的说法是一致的。]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程调度和内核同步]]></title>
    <url>%2F2018%2F10%2F20%2FLinux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%92%8C%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[一、什么叫进程调度？ 决定哪个进程投入运行，什么时候运行，运行多久，就叫进程调度。实现这样功能的程序，叫进程调度程序。 二、目的： 在进程快速响应和系统最大利用率之间寻找平衡。 例如I/O消耗型进程需要在键盘等I/O设备产生硬件中断时快速响应，其他时间不消耗处理器，大部分在等待。 而处理器消耗型进程，要占着CPU，例如视频播放器。 三、时间片的概念： 在进程被抢占之前，所能持续运行的时间。 时间片不能太短，否则显得进程调度反而消耗处理器的时间更长； 时间片不能太长，否则显得系统交互性能太差。 四、两种类型的进程：普通进程和实时进程 普通进程的调度算法是CFS（完全公平调度算法），称为SCHED_NORMAL；该算法不是直接分配时间片到进程，而是将处理器的使用比划分给进程，同时nice值（取值范围-20~19）只是作为进程获得的处理器运行比的权重。 针对实时进程，有两种调度策略，SCHED_FIFO和SCHED_RR，暂不详细讲解。 五、CFS算法实现： 时间记账：CFS用vruntime来实时跟踪记录一个进程运行了多少时间，还要运行多少时间； 进程选择：利用红黑树查找vruntime最小的进程（最左叶子节点）。CFS将进程加入到rbtree中是发生在进程变为可运行状态或者是通过fork调用第一次创建进程时；将进程从rbtree中删除是发生在进程阻塞或者终止时。调度器总是选择vruntime跑得最慢的那个进程来执行。这就是所谓的“完全公平”。为了区别不同优先级的进程，优先级高的进程vruntime增长得慢，以至于它可能得到更多的运行机会。 调度器入口：schedule（）函数。以优先级为序依次检查每一个调度类，从最高优先级的调度类中选择最高优先级的进程。 睡眠和唤醒：进程把自己标记为休眠状态，从可执行红黑树中移除，放入等待队列，然后调用schedule()选择和执行一个其他进程。 六、内核抢占和上下文切换： 上下文切换：由context_switch()函数负责。 用户抢占：内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用。用户抢占发生在以下情况，从系统调用返回用户空间时；从中断处理程序返回用户空间时。 内核抢占：Linux2.6开始支持内核抢占。内核抢占发生在： 中断处理程序正在执行，且返回内核空间之前 内核代码再一次具有可抢占性的时候 内核中的任务显式的调用schedule 内核中的任务阻塞时 七、内核同步： 在内核抢占和进程调度时，同一资源存在访问过程被打断，或者在打断和重新执行期间，被另一个进程访问的风险，如果没有内核同步技术，将得到意料之外的结果。 考虑内核同步时需要了解几个内核约束场景： 同一个tasklet不可能同时在几个CPU上执行。——所以仅被一种tasklet访问的数据结构不需要同步。 软中断和tasklet不能在一个给定的CPU上交错执行。——所以仅被软中断和tasklet访问的每CPU变量不需要同步。 中断ISR、软中断和tasklet既不可以被抢占也不能被阻塞。在最坏情况下，它们的执行将有轻微的延迟，因为在其执行的过程中可能发生其他的中断(内核控制路径的嵌套执行)。执行中断处理的内核控制路径不能被执行可延迟函数或系统调用服务例程的内核控制路径中断。 同步技术有哪些？（1）每CPU变量：主要是数据结构数组，每个CPU对应数组的一个元素。 （2）原子操作：原子的“读——修改——写”。 （3）自旋锁：加锁时忙等。一直旋转，等待锁释放，不会休眠。不可递归。 （4）信号量：加锁时阻塞等待（睡眠）。发现别人占用锁后就休眠自己，别人释放后就唤醒自己。 （5）顺序锁：基于访问计数器的锁。 （6）内存屏障：避免指令重新排序。]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>进程调度、锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM64内存布局总结]]></title>
    <url>%2F2018%2F10%2F20%2FARM64%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[综述： kernel image在被bootloader或者UEFI加载后，最终会跳到kernel的入口代码处，顺便将一些参数传给内核。kernel的启动包括两个阶段，分别由两个head.S描述。第一个阶段是内核的解压缩和重定位，第二阶段从stext开始，主要完成的工作有：参数检查，创建初始化页表，设置C代码运行环境，为跳转到内核第一个真正的C函数start_kernel做准备。所以，第二阶段这里包含了一次页表的创建，创建页表的入口是”__create_page_tables”。后面从c函数start_kernel开始，内核在start_kernel()-&gt;setup_arch()中通过arm64_memblock_init( )完成了memblock的初始化, 接着通过setup_arch()-&gt;paging_init()初始化分页机制。paging_init()是二次页表创建的接口，这个函数执行完，内核便布局了一套可供内核和进程安全运行的完整的虚拟内存空间。 另外，在paging_init的最后调用了bootmem_init，用以对内存基本数据结构(内存结点pg_data_t，内存域zone和页帧)做初始化工作，最后，内核将内存管理的工作从早期的内存分配器(bootmem或者memblock)移交到我们的内存管理器——buddy伙伴系统。 （1）内存基本数据结构： pg_data_t pgdat是描述node的数据结构，UMA结构只有一个node。pg_data_t pgda等价于struct pglist_data *pgdat。一个node又包含多个内存管理区域，如ZONE_NORMAL，ZONE_DMA等： （2）create_page_table完成了3种地址映射的页表空间填写：identity mapping kernel image mapping fdt mapping（fix mapping） 那么初期创建的这三种页表的作用是什么呢？ 在开启MMU之前做这样的映射，是为了enable_mmu附近的那段代码正确执行，MMU开启之后，程序将在虚拟地址上运行，如同链接地址和运行地址不一致时代码不能正常运行，程序在虚拟地址上运行时也要能找到其所映射到的物理地址，因此要建立这样的映射表。另外，初期创建的页表虽然会在二次创建页表时被覆盖，但也是paging_init-&gt;map_mem中二次创建页表的基础和依赖。 未完待续。。。]]></content>
      <categories>
        <category>内核</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Selinux-详解]]></title>
    <url>%2F2018%2F10%2F18%2FAndroid-Selinux-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[版本控制： 作者 更新内容 更新时间 董在强 第一次编写 2017-08-11 0.简介 SELINUX是可以理解为一种android上面的安全机制，是有美国国家安全局和一些公司设计的一个针对linux的安全加强系统我们可以通过配置SELINUX的相关policy，来定制自己的手机的一些权限。它比原有linux 权限机制更加严格。 1.现有权限介绍现有的权限:自主式访问控制, DACDAC 访问方式如下图所示： 上面的这个上关系可以通过以下方法来测试： 在一台linux机器建立两个普通账户。 用root 权限打开/tmp/目录，新建立目录，并打开。 用其中一个账户来编写如下的程序并通过ＧＣＣ编译 用同一个账户来touch t.txt 用同一个账户来执行编译出来的程序，发现可以正常执行 用另个一个账户来执行相同的程序，发现可以执行但不能读写文件 #include ”stdio.h“ void main(void) { FILE *fp; char ch; if ((fp = fopen("./t.txt","rt+")) == NULL) { printf("Cannot open file and Exit!"); exit(1); } printf("input a string:\n"); ch=getchar(); while (ch != '*') { fputc(ch,fp); ch=getchar(); } rewind(fp); ch = fgetc(fp); while (ch != EOF) { putchar(ch); ch = fgetc(fp); } printf("The end and Close file!\n"); fclose(fp); exit(0); } 2. 现有权限存在的问题 root 具有最高的权限:如果不小心某支程序被有心人士取得, 且该程序属于 root的权限,那么这支程序就可以在系统上进行任何资源的存取! 用户可以取得程序来变更档案资源的访问权限:如果你不小心将某个目录的权限设定为777,由于对任何人的权限会变成rwx,因此该目录就会被任何人所任意存取! 3.SElinux权限控制 SElinux权限控制:委任式访问控制, MAC 他可以针对特定的程序与特定的档案资源来进行权限的控管! 也就是说,即使你是root,那么在使用不同的程序时,你所能取得的权限并不一定是 root ,而得要看当时该程序的设定而定。如此一来,我们针对控制的『主体』变成了『程序』而不是用户.此外,这个主体程序也不能任意使用系统档案资源,因为每个档案资源也有针对该主体程序设定可取用的权限. 如此一来,控件目就细的多了!但整个系统程序那么多、档案那么多,一项一项控制可就没完没了! 所以SELinux 也提供一些预设的政策 (Policy) ,并在该政策内提供多个规则(rule),让你可以选择是否启用该控制规则! 4.SELinux 的运作模式 再次的重复说明一下,SELinux 是透过 MAC 的方式来控管程序,他控制的主体是程序, 而目标则是该程序能否读取的『档案资源』!所以先来说明一下这些的相关性主体 (Subject): SELinux 主要想要管理的就是程序,因此你可以将『主体』跟process 划上等号; 目标 (Object): 主体程序能否存取的『目标资源』一般就是文件系统。因此这个目标项目可以等文件系统划上等号;政策 (Policy): 由于程序与档案数量庞大,因此 SELinux 会依据某些服务来制订基本的存取安全性政策。这些政策内还会有详细的规则 (rule) 来指定不同的服务开放某些资源的存取与否。安全性本文 (security context): 我们刚刚谈到了主体、目标与政策面,但是主体能不能存取目标除了政策指定之外,主体与目标的安全性本文必须一致才能够顺利存取。 这个安全性本文 (security context) 有点类似文件系统的 rwx 啦!安全性本文的内容与设定是非常重要的! 如果设定错误,你的某些服务(主体程序)就无法存取文件系统(目标资源),当然就会一直出现『权限不符』的错误讯息了! 安全性本文存在于主体程序中与目标档案资源中。程序在内存内,所以安全性本文可以存入是没问题。那档案的安全性本文是记录在哪里呢?事实上,安全性本文是放置到档案的 inode 内的,因此主体程序想要读取目标档案资源时,同样需要读取 inode , 这 inode 内就可以比对安全性本文以及 rwx 等权限值是否正确,而给予适当的读取权限依据。 先看系统中的安全性文本： 1.先看文件的安全性文本 shell@msm8226:/ # ls -Z drwxr-xr-x root root u:object_r:cgroup:s0 acct drwxrwx--- system cache u:object_r:cache_file:s0 cache lrwxrwxrwx root root u:object_r:rootfs:s0 charger -&gt; /sbin/healthd dr-x------ root root u:object_r:rootfs:s0 config lrwxrwxrwx root root u:object_r:rootfs:s0 d -&gt; /sys/kernel/debug drwxrwx--x system system u:object_r:system_data_file:s0 data -rw-r--r-- root root u:object_r:rootfs:s0 default.prop drwxr-xr-x root root u:object_r:device:s0 dev lrwxrwxrwx root root u:object_r:rootfs:s0 etc -&gt; /system/etc -rw-r--r-- root root u:object_r:rootfs:s0 file_contexts dr-xr-x--- system system u:object_r:firmware_file:s0 firmware -rw-r----- root root u:object_r:rootfs:s0 fstab.qcom 2.再看一下进程的安全性文本： u:r:init:s0 root 1 0 /init u:r:kernel:s0 root 2 0 kthreadd u:r:kernel:s0 root 3 2 ksoftirqd/0 u:r:kernel:s0 root 6 2 kworker/u:0 u:r:kernel:s0 root 7 2 kworker/u:0H u:r:kernel:s0 root 8 2 migration/0 u:r:kernel:s0 root 9 2 watchdog/0 u:r:kernel:s0 root 25 2 khelper u:r:kernel:s0 root 26 2 netns u:r:kernel:s0 root 31 2 kworker/0:1H u:r:kernel:s0 root 32 2 modem_notifier u:r:kernel:s0 root 33 2 smd_channel_clo u:r:kernel:s0 root 34 2 smsm_cb_wq u:r:kernel:s0 root 36 2 rpm-smd u:r:kernel:s0 root 37 2 kworker/u:1H u:r:kernel:s0 root 44 2 irq/47-cpr u:r:kernel:s0 root 45 2 mpm 如上所示,安全性本文主要用冒号分为三个字段,这三个字段的意义为:Identify:Role:Type[:Range]身份识别:角色:类型这三个字段的意义仔细的说明一下吧:身份识别 (Identify):相当于账号方面的身份识别!主要的身份识别则有底下三种常见的类型: root:表示 root 的账号身份,如同上面的表格显示的是 root 家目录下的数据啊! system_u:表示系统程序方面的识别,通常就是程序啰; user_u:代表的是一般使用者账号相关的身份。 你会发现身份识别中,除了 root 之外,其他的识别后面都会加上『 _u 』的字样呢! 这个身份识别重点再让我们了解该数据为何种身份所有哩~ 而系统上面大部分的数据都会是 system_u 或root 啦!至于如果是在 /home 底下的数据,那么大部分应该就会是 user_u .角色 (Role):透过角色字段,我们可以知道这个数据是属于程序、档案资源还是代表使用者。一般的角色有: object_r:代表的是档案或目录等档案资源,这应该是最常见的啰; system_r:代表的就是程序啦!不过,一般使用者也会被指定成为 system_r 喔! 你也会发现角色的字段最后面使用『 _r 』来结尾!因为是 role 的意思嘛!类型 (Type) :(最重要!) 基本上,一个主体程序能不能读取到这个档案资源,与类型字段有关!而类型字段在档案与程序的定义不太相同,分别是: type:在档案资源 (Object) 上面称为类型 (Type); domain:在主体程序 (Subject) 则称为领域 (domain) 了! domain 需要与 type 搭配,则该程序才能够顺利的读取档案资源啦!级别(Range): 级别和SELinux为了满足军用和教育行业而设计的Multi-Level Security（MLS）机制有关。但是在Android中，因为只使用了S0所以这里不作更多的介绍。之间的关系如下图所示： 5.SElinxu为什么可以解决DAC的问题？ 先说一下，加入SElinux之后的访问是什么样的？ 加入SElinux之后，DAC的访问方式没有废弃，而是DAC和MAC 两者合作达成一个更加安全的访问控制。一般是先进行DAC的检查，然后再进行MAC的检查，两者都通过才可以访问。 SElinux 是怎么解决DAC的安全问题的？ DAC是基于用户的权限控制，也是说一个用户只要有读写这个文件的权限的，那么他就可以启动任何一个进程去读写这个文件，而MAC是基于域或者类型的访问控制，换句话说，它控制的对象不是用户，而是一个进程或者说是一个域（当然对于文件来说是类型），例如，以root启动一个程序, 如果是DAC 的时代，那这个上程序可以操作任何一个文件，但是MAC的时代，情况就一样了，就算是root要操作一个文件，也必需要符合相关政策 (Policy)的规定。所以说SElinux解决了ＤＡＣ的问题。 6.Android中SElinux的体现6.1 Android 中的安全性文本Android 中的安全性文本主要在这这个目录下：external/sepolicy/ 这这个目录下执行ls *_contexts可以看到： file_contexts genfs_contexts initial_sid_contexts port_contexts property_contexts seapp_contexts service_contexts 这些文件都是Android 中的安全性文本。 注意：进程的安全性文本在那存放？进程的安全性文本一般会由.rc的文件指定，在程序启动时候作为进程信息一部分存在，这样我们在执行ps -Ｚ时才能看到。介绍一下各个文件的作用： file_contexts：主要是文件相关的 seapp_contexts：主要是ＡＰＰ相关的 property_contexts：主要是系统属性相关的 initial_sid_contexts：主要是配合initial_sids（也在external/sepolicy）使用的，主要是用来初始化Object的安全性文本，在相关资料中这个动作称为Security Labeling port_contexts：主要是网络相关的 service_contexts：主要系统服务相关的 genfs_contexts：主要是一些特殊的文件相关以file_contexts为例，内容如下(实在是太长了，以下是部分)：可以对照安全性本文的介绍看一下。 ########################################### # Root / u:object_r:rootfs:s0 # Data files /adb_keys u:object_r:adb_keys_file:s0 /default\.prop u:object_r:rootfs:s0 /fstab\..* u:object_r:rootfs:s0 /init\..* u:object_r:rootfs:s0 /res(/.*)? u:object_r:rootfs:s0 /ueventd\..* u:object_r:rootfs:s0 # Executables /charger u:object_r:rootfs:s0 /init u:object_r:rootfs:s0 /sbin(/.*)? u:object_r:rootfs:s0 # Empty directories /lost\+found u:object_r:rootfs:s0 /proc u:object_r:rootfs:s0 # SELinux policy files /file_contexts u:object_r:rootfs:s0 /property_contexts u:object_r:rootfs:s0 /seapp_contexts u:object_r:rootfs:s0 /sepolicy u:object_r:rootfs:s0 ########################## # Devices # /dev(/.*)? u:object_r:device:s0 /dev/akm8973.* u:object_r:sensors_device:s0 /dev/accelerometer u:object_r:sensors_device:s0 /dev/adf[0-9]* u:object_r:graphics_device:s0 ...... /dev/tty u:object_r:owntty_device:s0 /dev/tty[0-9]* u:object_r:tty_device:s0 /dev/ttyS[0-9]* u:object_r:serial_device:s0 /dev/tun u:object_r:tun_device:s0 /dev/uhid u:object_r:uhid_device:s0 /dev/uinput u:object_r:uhid_device:s0 /dev/uio[0-9]* u:object_r:uio_device:s0 /dev/urandom u:object_r:urandom_device:s0 /dev/usb_accessory u:object_r:usbaccessory_device:s0 ############################# # System files # /system(/.*)? u:object_r:system_file:s0 /system/bin/sh -- u:object_r:shell_exec:s0 /system/bin/run-as -- u:object_r:runas_exec:s0 /system/bin/bootanimation u:object_r:bootanim_exec:s0 /system/bin/app_process32 u:object_r:zygote_exec:s0 /system/bin/app_process64 u:object_r:zygote_exec:s0 /system/bin/servicemanager u:object_r:servicemanager_exec:s0 /system/bin/surfaceflinger u:object_r:surfaceflinger_exec:s0 ...... /system/bin/uncrypt u:object_r:uncrypt_exec:s0 /system/bin/logwrapper u:object_r:system_file:s0 /system/bin/vdc u:object_r:vdc_exec:s0 /system/bin/install-recovery.sh u:object_r:install_recovery_exec:s0 /system/bin/dex2oat u:object_r:dex2oat_exec:s0 # patchoat executable has (essentially) the same requirements as dex2oat. /system/bin/patchoat u:object_r:dex2oat_exec:s0 ############################# # Vendor files # /vendor(/.*)? u:object_r:system_file:s0 /vendor/bin/gpsd u:object_r:gpsd_exec:s0 ############################# # Data files # /data(/.*)? u:object_r:system_data_file:s0 /data/.layout_version u:object_r:install_data_file:s0 ...... /data/mediadrm(/.*)? u:object_r:media_data_file:s0 /data/property(/.*)? u:object_r:property_data_file:s0 # Misc data /data/misc/adb(/.*)? u:object_r:adb_keys_file:s0 /data/misc/audio(/.*)? u:object_r:audio_data_file:s0 /data/misc/bluetooth(/.*)? u:object_r:bluetooth_data_file:s0 /data/misc/bluedroid(/.*)? u:object_r:bluetooth_data_file:s0 /data/misc/bluedroid/\.a2dp_ctrl u:object_r:bluetooth_socket:s0 ...... /data/misc/user(/.*)? u:object_r:misc_user_data_file:s0 /data/misc/vpn(/.*)? u:object_r:vpn_data_file:s0 /data/misc/wifi(/.*)? u:object_r:wifi_data_file:s0 /data/misc/wifi/sockets(/.*)? u:object_r:wpa_socket:s0 /data/misc/wifi/sockets/wpa_ctrl.* u:object_r:system_wpa_socket:s0 /data/misc/wifi/hostapd(/.*)? u:object_r:wpa_socket:s0 /data/misc/zoneinfo(/.*)? u:object_r:zoneinfo_data_file:s0 # coredump directory for userdebug/eng devices /cores(/.*)? u:object_r:coredump_file:s0 # Wallpaper file for other users /data/system/users/[0-9]+/wallpaper u:object_r:wallpaper_file:s0 ############################# # efs files # /efs(/.*)? u:object_r:efs_file:s0 ############################# # Cache files # /cache(/.*)? u:object_r:cache_file:s0 /cache/.*\.data u:object_r:cache_backup_file:s0 /cache/.*\.restore u:object_r:cache_backup_file:s0 # LocalTransport (backup) uses this directory /cache/backup(/.*)? u:object_r:cache_backup_file:s0 ############################# # sysfs files # /sys/devices/platform/nfc-power/nfc_power -- u:object_r:sysfs_nfc_power_writable:s0 /sys/devices/system/cpu(/.*)? u:object_r:sysfs_devices_system_cpu:s0 /sys/power/wake_lock -- u:object_r:sysfs_wake_lock:s0 /sys/power/wake_unlock -- u:object_r:sysfs_wake_lock:s0 /sys/kernel/uevent_helper -- u:object_r:usermodehelper:s0 /sys/module/lowmemorykiller(/.*)? -- u:object_r:sysfs_lowmemorykiller:s0 ############################# # asec containers /mnt/asec(/.*)? u:object_r:asec_apk_file:s0 /mnt/asec/[^/]+/[^/]+\.zip u:object_r:asec_public_file:s0 /mnt/asec/[^/]+/lib(/.*)? u:object_r:asec_public_file:s0 /data/app-asec(/.*)? u:object_r:asec_image_file:s0 6.2 Android 中的政策 MAC基本管理单位是TEAC（Type Enforcement Accesc Control）,体现ＴＥＡＣ的东西正好就是我们这里将要介绍的政策。政策文件存在位置:external/sepolicy 在这里我们看到大量的.te文件，其实里面就是TEAC的各种配置。因为程序和文件实在是太多了，所以Android中配置都是基于域和类型来的。也就是在这些.te中你可能经常会看到像下的这句：allow system_server i2c_device:chr_file { open read write ioctl};上面的这句就是政策文件的一项配置，整个政策文件都是由这样的语句组成的。这样的语句的语法格式是：rule_name source_type target_type : class perm_set分开的介绍： rule_name: 主要是allow,allowaudit,dontaudit,neverallow 这里没什么好说就是一种动作，允许或者never允许，其他两个因为很少去用，也没具体查是什么意思source_type:指程序或者是程序所属的域（domain）在相关的.te文件中定义，如system_server这个domain在system_server.te中定义： system_server.te:5:type system_server, domain, mlstrustedsubject; target_type:指文件或者文件的类型在相关的.te文件中定义。 关于类型定义一会再详细介绍一下。 class：这个比较复杂，一会重点介绍perm_set：在该类Object Class中所定义的操作。 class这个地方不好理解,其实不知道应该怎么去解释它，可能需要和perm_set结合起来去理解会好一点。下面详细说一下： 1.cat external/sepolicy/security_classes可以看到如下信息： # Classes marked as userspace are classes # for userspace object managers class security class process class system class capability # file-related classes class filesystem class file class dir class fd class lnk_file class chr_file class blk_file class sock_file class fifo_file # network-related classes class socket class tcp_socket class udp_socket class rawip_socket class node class netif class netlink_socket class packet_socket class key_socket class unix_stream_socket class unix_dgram_socket 根据SELinux规范，Object Class类型由class关键字申明2.cat external/sepolicy/access_vectors可以看到如下信息： # # Define a common prefix for file access vectors. # common file { ioctl read write create getattr setattr lock relabelfrom relabelto append unlink link rename execute swapon quotaon mounton } # # Define a common prefix for socket access vectors. # common socket { # inherited from file ioctl read write create getattr setattr lock relabelfrom relabelto append # socket-specific bind connect listen accept getopt setopt shutdown recvfrom sendto recv_msg send_msg name_bind } SELinux规范中，定义perm set有两种方式: common common_name { permission_name … }common定义的perm set能被另外一种perm set命令class所继承 class class_name [ inherits common_name ] { permission_name … }inherits表示继承了某个common定义的权限 注意，class命令定义的权限其实针对得就是某个object class。它不能被其他class继承 下面用例子说明一下： common file { ioctl read write create getattr setattr lock relabelfrom relabelto append unlink link rename execute swapon quotaon mounton } class dir inherits file { add_name remove_name reparent search rmdir open audit_access execmod } 6.3 类型定义 类型定义通过type 来进行type命令的完整格式为：type type_id [alias alias_id,] [attribute_id]其中，方括号中的内容为可选。alias指定了type的别名，可以指定多个别名。下面这个例子定义了一个名为shell的type，它和一个名为domain的属性（attribute）关联 :type shell, domain; 属性由attribute关键字定义，如attributes文件中定义的SEAndroid使用的属性有： attribute domain attribute file_type 可以在定义type的时候，直接将其和某个attribute关联，也可以单独通过typeattribue将某个type和某个或多个attribute关联起来，如下面这个例子将前面定义的system类型和mlstrustedsubject属性关联了起来typeattribute system mlstrustedsubject这里需要重点说明一下attribute这个东西这里的attribute正确的意思不是属性，而是群组的意思。请注意！！！ attribute的作用通过如下的例子来说明： #定义两个type，分别是A_t和B_t，它们都管理到attribute_test type A_t attribute_test; type B_t attribute_test; #写一个allow语句，直接针对attribute_test allow attribute_test C_t:file {read write}; #上面这个allow语句在编译后的安全策略文件中会被如下两条语句替代： allow A_t C_t:file {read write}; allow B_t C_t:file {read write}; 7.如何快速添加一安全性规则 首先确认你要解的问题的中是那个进程要访问那个文件 由于进程已经存在那个它安全性文本的定义肯定是存在只要找到就行类似这样一条语句u:r:kernel:s0 确认一下文件的安全性文本的定义是否存在，如果不存在则要定义（一般情况下是不存在）,3.1定义类型(参考6.3)3.2在contexts定义安全性文本（参考6.2） 确认要进行那种操作也就是要确定class和perm_set. 在相关的.te文件加入规则也就是一条allow相关的语句(参考6.2)。 例子：如我们在system_server中加入一个服务，这个服务要操作/dev/i2c-2这个设备结点。那么安上面的方法： 确认问题：system_server要访问/dev/i2c-2 确定进程system_server信息u:r:system_server:s0 system 849 232 system_server 由于/dev/i2c-2的安全性文本不存在，所以我们做定义3.1,type i2c2_device, dev_type;3.2,/dev/i2c-2 u:object_r:i2c2_device:s0 确认calss perm_set为chr_file {open read write ioctl} 加入规则allow system_server i2c2_device:chr_file { open read write ioctl}; 注意：以上信息要写入合适的文件，要以当时的问题来决定。]]></content>
      <categories>
        <category>selinux</category>
      </categories>
      <tags>
        <tag>Android-selinux</tag>
      </tags>
  </entry>
</search>
